# .github/workflows/release.yml

name: Build and Release AppImage (Ubuntu LTS + Fedora)

# --- Tells GitHub Actions WHEN to run this workflow ---
on:
  push:
    tags:
      - 'v*' # Trigger on tags like v0.1.0, v1.0.0 etc.
  # Allow manual triggering from the Actions tab in GitHub
  workflow_dispatch:
# --- End of trigger definition ---

# Permissions needed for the workflow to interact with the repo
permissions:
  contents: write       # Required by gh release create/upload/edit
  pull-requests: write  # Required by gh pr comment

jobs:
  # == JOB 1: Build the AppImage on multiple OS versions ==
  build:
    strategy:
      # Define the OS versions to run the build job on
      matrix:
        # Ubuntu LTS (old & new) + Latest Fedora
        os: [ubuntu-20.04, ubuntu-24.04, fedora-latest]
      # Don't cancel all builds if one OS in the matrix fails
      fail-fast: false
    # Dynamic job name based on the OS from the matrix
    name: Build on ${{ matrix.os }}
    # Set the runner environment based on the OS from the matrix
    runs-on: ${{ matrix.os }}

    steps:
      # Step 1.1: Get the source code
      - name: Checkout code
        uses: actions/checkout@v4
        # Fetch all history and tags for changelog generation later
        with:
          fetch-depth: 0

      # Step 1.2: Set up the Python environment
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11' # Specify desired Python version

      # Step 1.3: Install OS-level packages needed for the build
      - name: Install System Build Dependencies
        run: |
          if [[ "${{ matrix.os }}" == "fedora-latest" ]]; then
            echo "Installing dependencies for Fedora..."
            # Install necessary tools and libraries using dnf
            sudo dnf install -y \
              patchelf \
              desktop-file-utils \
              fuse-libs \
              fakeroot \
              dbus-devel \
              pkgconf-pkg-config \
              glib2-devel \
              gcc \
              make \
              python3-devel
          elif [[ "${{ matrix.os }}" == ubuntu-* ]]; then
            echo "Installing dependencies for Ubuntu (${{ matrix.os }})..."
            sudo apt-get update
            # Install necessary tools and libraries using apt
            sudo apt-get install -y --no-install-recommends \
              patchelf \
              desktop-file-utils \
              libfuse2 \
              fakeroot \
              libdbus-1-dev \
              pkg-config \
              libglib2.0-dev
          else
             echo "ERROR: Unknown OS ${{ matrix.os }}"
             exit 1
          fi
          echo "System dependencies installed on ${{ matrix.os }}"

      # Step 1.4: Get the appimagetool utility
      - name: Download and Install appimagetool
        run: |
          APPIMAGETOOL_URL="https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage"
          echo "Downloading appimagetool from ${APPIMAGETOOL_URL}..."
          wget -q "${APPIMAGETOOL_URL}" -O appimagetool.AppImage
          chmod +x appimagetool.AppImage
          # Use sudo on Linux runners
          if [[ "$RUNNER_OS" == "Linux" ]]; then
             sudo mv appimagetool.AppImage /usr/local/bin/appimagetool
             echo "appimagetool installed to /usr/local/bin/appimagetool"
          else
             # Handle other OS if needed, though matrix is Linux only now
             mv appimagetool.AppImage ./appimagetool
             echo "::add-path::$(pwd)" # Add current dir to PATH for this job
             echo "appimagetool added to PATH for non-Linux runner"
          fi


      # Step 1.5: Extract the project version from pyproject.toml
      - name: Get Project Version
        id: get_project_version
        run: |
          # Robust version reading from pyproject.toml (supports project/poetry tables and Python 3.11+ tomllib or older tomli)
          VERSION_CMD=""
          if python -c "import sys; sys.exit(0) if sys.version_info >= (3, 11) else sys.exit(1)"; then
              if python -c "import tomllib; data=tomllib.load(open('pyproject.toml', 'rb')); exit(0) if 'project' in data and 'version' in data['project'] else exit(1)"; then
                  VERSION_CMD="import tomllib; print(tomllib.load(open('pyproject.toml', 'rb'))['project']['version'])"; echo "Reading version using tomllib [project]"
              elif python -c "import tomllib; data=tomllib.load(open('pyproject.toml', 'rb')); exit(0) if 'tool' in data and 'poetry' in data['tool'] and 'version' in data['tool']['poetry'] else exit(1)"; then
                  VERSION_CMD="import tomllib; print(tomllib.load(open('pyproject.toml', 'rb'))['tool']['poetry']['version'])"; echo "Reading version using tomllib [poetry]"
              else echo "ERROR: Could not find version key in pyproject.toml (Python 3.11+)"; cat pyproject.toml; exit 1; fi
          else
              # Older Python, try installing and using tomli
              pip install tomli
              if python -c "import tomli; data=tomli.load(open('pyproject.toml', 'rb')); exit(0) if 'project' in data and 'version' in data['project'] else exit(1)"; then
                  VERSION_CMD="import tomli; print(tomli.load(open('pyproject.toml', 'rb'))['project']['version'])"; echo "Reading version using tomli [project]"
              elif python -c "import tomli; data=tomli.load(open('pyproject.toml', 'rb')); exit(0) if 'tool' in data and 'poetry' in data['tool'] and 'version' in data['tool']['poetry'] else exit(1)"; then
                  VERSION_CMD="import tomli; print(tomli.load(open('pyproject.toml', 'rb'))['tool']['poetry']['version'])"; echo "Reading version using tomli [poetry]"
              else echo "ERROR: Could not find version key in pyproject.toml (tomli)"; cat pyproject.toml; exit 1; fi
          fi
          PROJECT_VERSION=$(python -c "${VERSION_CMD}")
          if [ -z "$PROJECT_VERSION" ]; then echo "ERROR: Failed to extract project version."; exit 1; fi
          # Make the version available to other steps/jobs
          echo "project_version=${PROJECT_VERSION}" >> $GITHUB_OUTPUT
          echo "Project version found: ${PROJECT_VERSION}"

      # Step 1.6: Install Python dependencies (including optional ones)
      - name: Install Python Build Dependencies & Project
        run: |
          python -m pip install --upgrade pip
          pip install build setuptools wheel
          echo "Installing/Upgrading PySide6 (pinned)..."
          pip install --upgrade "PySide6==6.8.3" # Use consistent latest stable PySide
          pip show PySide6 # Log installed version for verification
          echo "Installing project dependencies..."
          pip install .
          echo "Installing optional dependencies [notifications]..."
          # Ensure dbus-python builds correctly, headers installed in step 1.3
          pip install ".[notifications]"

      # Step 1.7: Run the main build script to create the AppDir and initial AppImage
      - name: Build AppImage using build.sh
        run: |
          chmod +x ./build.sh
          echo "Running build script on ${{ matrix.os }}..."
          # Tell build.sh to create the AppImage
          ./build.sh --appimage

      # Step 1.8: Rename the AppImage to include OS tag for clarity in releases
      - name: Determine and Prepare AppImage Filename for Upload
        id: prepare_appimage
        run: |
          VERSION="${{ steps.get_project_version.outputs.project_version }}"
          if [ -z "$VERSION" ]; then echo "ERROR: Project version is empty. Cannot determine filename."; exit 1; fi

          # Create an OS tag like 'ubuntu2004', 'ubuntu2404', 'fedoralatest'
          # Remove '-' and '.' characters from the matrix OS variable
          OS_TAG=$(echo "${{ matrix.os }}" | sed -e 's/-//g' -e 's/\.//g')

          ORIGINAL_FILENAME="chromadesk-${VERSION}-x86_64.AppImage"
          NEW_FILENAME="chromadesk-${VERSION}-x86_64-${OS_TAG}.AppImage"

          echo "Checking for original file: ${ORIGINAL_FILENAME}"
          if [[ ! -f "${ORIGINAL_FILENAME}" ]]; then
            echo "ERROR: Expected AppImage file ${ORIGINAL_FILENAME} not found after build!"
            ls -lAh . ; echo "Listing *.AppImage files:" ; ls -l *.AppImage
            exit 1
          fi
          echo "Renaming ${ORIGINAL_FILENAME} to ${NEW_FILENAME}"
          mv "${ORIGINAL_FILENAME}" "${NEW_FILENAME}"
          echo "filename=${NEW_FILENAME}" >> $GITHUB_OUTPUT
          echo "AppImage prepared for upload: ${NEW_FILENAME}"

      # Step 1.9: Upload the renamed AppImage as a workflow artifact
      - name: Upload AppImage Artifact
        uses: actions/upload-artifact@v4
        with:
          # Unique name for the artifact based on the OS build
          name: chromadesk-appimage-${{ matrix.os }} # e.g., chromadesk-appimage-fedora-latest
          # Path to the file to upload (using output from previous step)
          path: ${{ steps.prepare_appimage.outputs.filename }} # e.g., chromadesk-X.Y.Z-x86_64-fedoralatest.AppImage
          # How long to keep the artifact (short retention is fine as it's used by the release job)
          retention-days: 1

  # == JOB 2: Create the GitHub Release and Comment on PR ==
  release:
    name: Create GitHub Release and Comment
    needs: build
    runs-on: ubuntu-latest
    # Only run this job if triggered by a tag push
    if: startsWith(github.ref, 'refs/tags/')

    steps:
      # Step 2.1: Download all artifacts produced by the 'build' job matrix runs
      - name: Download all AppImage artifacts
        uses: actions/download-artifact@v4
        with:
          path: appimages # Download all artifacts into the 'appimages' directory

      # Step 2.2: List downloaded artifacts (for debugging)
      - name: List downloaded artifacts
        run: |
          echo "Downloaded artifacts structure:"
          ls -lR appimages/
          # Move files out of subdirectories for easier handling with gh release create
          find appimages -type f -name '*.AppImage' -exec mv {} appimages/ \;
          echo "Files after moving:"
          ls -l appimages/

      # Step 2.3: Define the custom notes footer
      # Using an intermediate file avoids issues with multiline strings in env vars across steps
      - name: Define Custom Release Notes Footer
        id: custom_notes
        run: |
          cat << 'EOF' > custom_notes_footer.md
          ---

          **AppImage Build Details:**

          This release includes builds for different compatibility targets:

          *   **`...-ubuntu2004.AppImage`**: Built on Ubuntu 20.04 (GLIBC 2.31). Recommended for **older systems** (e.g., Ubuntu 20.04, Debian 11, RHEL 8 derivatives).
          *   **`...-ubuntu2404.AppImage`**: Built on Ubuntu 24.04 (GLIBC 2.39). Recommended for **very recent systems** (e.g., Ubuntu 24.04+, Fedora 40+, Debian 13+/testing).
          *   **`...-fedoralatest.AppImage`**: Built on Fedora (latest). Recommended for **Fedora users and potentially other very recent distributions** using similar library versions (libc, C++, etc.) as current Fedora.

          Please download the version appropriate for your Linux distribution. Using the build matching your base system (or an older one) generally provides the best compatibility.
          EOF
          echo "Custom notes footer written to custom_notes_footer.md"

      # Step 2.4: Create GitHub Release using GitHub CLI
      - name: Create GitHub Release
        id: create_release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG_NAME: ${{ github.ref_name }} # Get tag name like v1.0.0
        run: |
          echo "Creating release for tag ${TAG_NAME}..."
          # Use gh release create:
          # - --generate-notes automatically creates changelog from PRs since last tag
          # - --notes-file appends the content of our custom footer file
          # - The final arguments are the asset files to upload
          gh release create "${TAG_NAME}" \
            --title "Release ${TAG_NAME} (Multi-OS Build)" \
            --generate-notes \
            --notes-file custom_notes_footer.md \
            appimages/*.AppImage

          echo "Release created successfully."
          # Get the final body of the created release (auto-generated + custom)
          # Store it in GITHUB_OUTPUT for the next step
          RELEASE_BODY=$(gh release view "${TAG_NAME}" --json body --jq '.body')
          echo "release_body<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASE_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "Release body captured."

      # Step 2.5: Find the Pull Request associated with the tag's commit
      - name: Find Associated Pull Request
        id: find_pr
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMIT_SHA: ${{ github.sha }} # SHA of the commit the tag points to
        run: |
          echo "Searching for merged PR associated with commit ${COMMIT_SHA}..."
          # Search for merged PRs where the merge commit SHA matches the tag's commit SHA
          # Use `// ""` to output an empty string if no PR is found (jq trick)
          PR_NUMBER=$(gh pr list --state merged --search "${COMMIT_SHA}" --json number --jq '.[0].number // ""')

          if [[ -n "$PR_NUMBER" ]]; then
            echo "Found associated PR #${PR_NUMBER}"
            echo "pr_number=${PR_NUMBER}" >> $GITHUB_OUTPUT
          else
            echo "No associated merged PR found for commit ${COMMIT_SHA}."
            echo "pr_number=" >> $GITHUB_OUTPUT # Ensure output is empty
          fi

      # Step 2.6: Comment on the associated Pull Request (if found)
      - name: Comment Release Notes on PR
        # Only run if a PR number was found in the previous step
        if: steps.find_pr.outputs.pr_number != ''
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ steps.find_pr.outputs.pr_number }}
          # Use the captured release body from the create_release step output
          RELEASE_BODY: ${{ steps.create_release.outputs.release_body }}
        run: |
          echo "Posting release notes to PR #${PR_NUMBER}..."
          # Use process substitution to pass the potentially large body via stdin
          gh pr comment "${PR_NUMBER}" --body-file <(echo "$RELEASE_BODY")
          echo "Comment posted successfully."
